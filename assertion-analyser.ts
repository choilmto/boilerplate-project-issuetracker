/*
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *       DO NOT EDIT THIS FILE
 *       For FCC testing purposes!
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
type Parsed = {
  start: number;
  end: number;
  obj: string;
};
function objParser(str: string, init: null | number): Parsed {
  // finds objects, arrays, strings, and function arguments
  // between parens, because they may contain ','
  var openSym: string[] = ["[", "{", '"', "'", "("];
  var closeSym: string[] = ["]", "}", '"', "'", ")"];
  var type: number;
  for (var i: number = init || 0; i < str.length; i++) {
    type = openSym.indexOf(str[i]);
    if (type !== -1) break;
  }
  if (type === -1) return null;
  var open: string = openSym[type];
  var close: string = closeSym[type];
  var count: number = 1;
  for (var k: number = i + 1; k < str.length; k++) {
    if (open === '"' || open === "'") {
      if (str[k] === close) count--;
      if (str[k] === "\\") k++;
    } else {
      if (str[k] === open) count++;
      if (str[k] === close) count--;
    }
    if (count === 0) break;
  }
  if (count !== 0) return null;
  var obj: string = str.slice(i, k + 1);
  return {
    start: i,
    end: k,
    obj: obj,
  };
}

type Replaced = {
  str: string;
  dictionary: string[];
};
function replacer(str: string): Replaced {
  // replace objects with a symbol ( __#n)
  var obj: Parsed;
  var cnt: number = 0;
  var data: string[] = [];
  while ((obj = objParser(str, null))) {
    data[cnt] = obj.obj;
    str =
      str.substring(0, obj.start) + "__#" + cnt++ + str.substring(obj.end + 1);
  }
  return {
    str: str,
    dictionary: data,
  };
}

function splitter(str: string): string[] {
  // split on commas, then restore the objects
  var strObj: Replaced = replacer(str);
  var args: string[] = strObj.str.split(",");
  args = args.map(function (a: string): string {
    var m: null | string[] = a.match(/__#(\d+)/);
    while (m) {
      a = a.replace(/__#(\d+)/, strObj.dictionary[m[1]]);
      m = a.match(/__#(\d+)/);
    }
    return a.trim();
  });
  return args;
}

export type Assertions = {
  method: string;
  args: string[];
};
export function assertionAnalyser(
  contents: string
): Assertions[] | "invalid assertion" {
  // already filtered in the test runner
  // // remove comments
  // body = body.replace(/\/\/.*\n|\/\*.*\*\//g, '');
  // // get test function body
  // body = body.match(/\{\s*([\s\S]*)\}\s*$/)[1];

  if (!contents) return "invalid assertion";
  // replace assertions bodies, so that they cannot
  // contain the word 'assertion'

  var body: string = contents.match(
    /(?:browser\s*\.\s*)?assert\s*\.\s*\w*\([\s\S]*\)/
  )[0];
  var s: Replaced = replacer(body);
  // split on 'assertion'
  var splittedAssertions: string[] = s.str.split("assert");
  var assertions: string[] = splittedAssertions.slice(1);
  // match the METHODS

  var assertionBodies: number[] = [];
  var methods: string[] = assertions.map(function (
    a: string,
    i: number
  ): string {
    var m: null | string[] = a.match(/^\s*\.\s*(\w+)__#(\d+)/);
    assertionBodies.push(parseInt(m[2]));
    var pre: string = splittedAssertions[i].match(/browser\s*\.\s*/)
      ? "browser."
      : "";
    return pre + m[1];
  });
  if (
    methods.some(function (m: string): boolean {
      return !m;
    })
  )
    return "invalid assertion";
  // remove parens from the assertions bodies
  var bodies: string[] = assertionBodies.map(function (b: number): string {
    return s.dictionary[b].slice(1, -1).trim();
  });
  var analysed: Assertions[] = methods.map(function (
    m: string,
    i: number
  ): Assertions {
    return {
      method: m,
      args: splitter(bodies[i]), //replace objects, split on ',' ,then restore objects
    };
  });
  return analysed;
}
